var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  QQ: () => types_exports,
  QQBot: () => QQBot,
  QQGuildMessageEncoder: () => QQGuildMessageEncoder,
  QQMessageEncoder: () => QQMessageEncoder,
  WsClient: () => WsClient,
  adaptSession: () => adaptSession,
  decodeChannel: () => decodeChannel,
  decodeGroupMessage: () => decodeGroupMessage,
  decodeGuild: () => decodeGuild,
  decodeGuildMember: () => decodeGuildMember,
  decodeMessage: () => decodeMessage,
  decodeUser: () => decodeUser,
  default: () => src_default,
  escapeMarkdown: () => escapeMarkdown,
  setupReaction: () => setupReaction
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var types_exports = {};
__export(types_exports, {
  AnnounceType: () => AnnounceType,
  ChannelPrivateType: () => ChannelPrivateType,
  ChannelSpeakPermission: () => ChannelSpeakPermission,
  ChannelSubType: () => ChannelSubType,
  ChannelType: () => ChannelType,
  ChatType: () => ChatType,
  DefaultRoles: () => DefaultRoles,
  DeleteHistoryMsgDays: () => DeleteHistoryMsgDays,
  EmojiType: () => EmojiType,
  Forum: () => Forum,
  Intents: () => Intents,
  Message: () => Message,
  Opcode: () => Opcode,
  ReactionTargetType: () => ReactionTargetType,
  RemindType: () => RemindType
});
var Intents = /* @__PURE__ */ ((Intents2) => {
  Intents2[Intents2["GUILDS"] = 1] = "GUILDS";
  Intents2[Intents2["GUILD_MEMBERS"] = 2] = "GUILD_MEMBERS";
  Intents2[Intents2["GUILD_MESSAGES"] = 512] = "GUILD_MESSAGES";
  Intents2[Intents2["GUILD_MESSAGE_REACTIONS"] = 1024] = "GUILD_MESSAGE_REACTIONS";
  Intents2[Intents2["DIRECT_MESSAGES"] = 4096] = "DIRECT_MESSAGES";
  Intents2[Intents2["OPEN_FORUMS_EVENT"] = 262144] = "OPEN_FORUMS_EVENT";
  Intents2[Intents2["AUDIO_OR_LIVE_CHANNEL_MEMBER"] = 524288] = "AUDIO_OR_LIVE_CHANNEL_MEMBER";
  Intents2[Intents2["USER_MESSAGE"] = 33554432] = "USER_MESSAGE";
  Intents2[Intents2["INTERACTIONS"] = 67108864] = "INTERACTIONS";
  Intents2[Intents2["MESSAGE_AUDIT"] = 134217728] = "MESSAGE_AUDIT";
  Intents2[Intents2["FORUM_EVENT"] = 268435456] = "FORUM_EVENT";
  Intents2[Intents2["AUDIO_ACTION"] = 536870912] = "AUDIO_ACTION";
  Intents2[Intents2["PUBLIC_GUILD_MESSAGES"] = 1073741824] = "PUBLIC_GUILD_MESSAGES";
  return Intents2;
})(Intents || {});
var Opcode = /* @__PURE__ */ ((Opcode2) => {
  Opcode2[Opcode2["DISPATCH"] = 0] = "DISPATCH";
  Opcode2[Opcode2["HEARTBEAT"] = 1] = "HEARTBEAT";
  Opcode2[Opcode2["IDENTIFY"] = 2] = "IDENTIFY";
  Opcode2[Opcode2["RESUME"] = 6] = "RESUME";
  Opcode2[Opcode2["RECONNECT"] = 7] = "RECONNECT";
  Opcode2[Opcode2["INVALID_SESSION"] = 9] = "INVALID_SESSION";
  Opcode2[Opcode2["HELLO"] = 10] = "HELLO";
  Opcode2[Opcode2["HEARTBEAT_ACK"] = 11] = "HEARTBEAT_ACK";
  Opcode2[Opcode2["HTTP_CALLBACK_ACK"] = 12] = "HTTP_CALLBACK_ACK";
  Opcode2[Opcode2["ADDRESS_VERIFICATION"] = 13] = "ADDRESS_VERIFICATION";
  return Opcode2;
})(Opcode || {});
var Message;
((Message2) => {
  let Type;
  ((Type2) => {
    Type2[Type2["TEXT"] = 0] = "TEXT";
    Type2[Type2["MIXED"] = 1] = "MIXED";
    Type2[Type2["MARKDOWN"] = 2] = "MARKDOWN";
    Type2[Type2["ARK"] = 3] = "ARK";
    Type2[Type2["EMBED"] = 4] = "EMBED";
    Type2[Type2["MEDIA"] = 7] = "MEDIA";
  })(Type = Message2.Type || (Message2.Type = {}));
  let File;
  ((File2) => {
    let Type2;
    ((Type3) => {
      Type3[Type3["IMAGE"] = 1] = "IMAGE";
      Type3[Type3["VIDEO"] = 2] = "VIDEO";
      Type3[Type3["AUDIO"] = 3] = "AUDIO";
      Type3[Type3["FILE"] = 4] = "FILE";
    })(Type2 = File2.Type || (File2.Type = {}));
  })(File = Message2.File || (Message2.File = {}));
})(Message || (Message = {}));
var DefaultRoles = /* @__PURE__ */ ((DefaultRoles2) => {
  DefaultRoles2[DefaultRoles2["ALL"] = 1] = "ALL";
  DefaultRoles2[DefaultRoles2["ADMIN"] = 2] = "ADMIN";
  DefaultRoles2[DefaultRoles2["OWNER"] = 4] = "OWNER";
  DefaultRoles2[DefaultRoles2["SUBCHANNEL_ADMIN"] = 5] = "SUBCHANNEL_ADMIN";
  return DefaultRoles2;
})(DefaultRoles || {});
var ChannelType = /* @__PURE__ */ ((ChannelType2) => {
  ChannelType2[ChannelType2["TEXT"] = 0] = "TEXT";
  ChannelType2[ChannelType2["VOICE"] = 2] = "VOICE";
  ChannelType2[ChannelType2["GROUP"] = 4] = "GROUP";
  ChannelType2[ChannelType2["LIVE"] = 10005] = "LIVE";
  ChannelType2[ChannelType2["APPLICATION"] = 10006] = "APPLICATION";
  ChannelType2[ChannelType2["FORUM"] = 10007] = "FORUM";
  return ChannelType2;
})(ChannelType || {});
var ChannelSubType = /* @__PURE__ */ ((ChannelSubType2) => {
  ChannelSubType2[ChannelSubType2["IDLE"] = 0] = "IDLE";
  ChannelSubType2[ChannelSubType2["ANNOUNCEMENT"] = 1] = "ANNOUNCEMENT";
  ChannelSubType2[ChannelSubType2["STRATEGY"] = 2] = "STRATEGY";
  ChannelSubType2[ChannelSubType2["BLACK"] = 3] = "BLACK";
  return ChannelSubType2;
})(ChannelSubType || {});
var ChannelPrivateType = /* @__PURE__ */ ((ChannelPrivateType2) => {
  ChannelPrivateType2[ChannelPrivateType2["PUBLIC"] = 0] = "PUBLIC";
  ChannelPrivateType2[ChannelPrivateType2["ADMIN_ONLY"] = 1] = "ADMIN_ONLY";
  ChannelPrivateType2[ChannelPrivateType2["SELECTED_MEMBERS"] = 2] = "SELECTED_MEMBERS";
  return ChannelPrivateType2;
})(ChannelPrivateType || {});
var ChannelSpeakPermission = /* @__PURE__ */ ((ChannelSpeakPermission2) => {
  ChannelSpeakPermission2[ChannelSpeakPermission2["INVALID"] = 0] = "INVALID";
  ChannelSpeakPermission2[ChannelSpeakPermission2["ALL"] = 1] = "ALL";
  ChannelSpeakPermission2[ChannelSpeakPermission2["SELECTED_MEMBERS"] = 2] = "SELECTED_MEMBERS";
  return ChannelSpeakPermission2;
})(ChannelSpeakPermission || {});
var AnnounceType = /* @__PURE__ */ ((AnnounceType2) => {
  AnnounceType2[AnnounceType2["MEMBER"] = 0] = "MEMBER";
  AnnounceType2[AnnounceType2["WELCOME"] = 1] = "WELCOME";
  return AnnounceType2;
})(AnnounceType || {});
var ReactionTargetType = /* @__PURE__ */ ((ReactionTargetType2) => {
  ReactionTargetType2["MESSAGE"] = "ReactionTargetType_MSG";
  ReactionTargetType2["POST"] = "ReactionTargetType_FEED";
  ReactionTargetType2["COMMENT"] = "ReactionTargetType_COMMNENT";
  ReactionTargetType2["REPLY"] = "ReactionTargetType_REPLY";
  return ReactionTargetType2;
})(ReactionTargetType || {});
var EmojiType = /* @__PURE__ */ ((EmojiType2) => {
  EmojiType2[EmojiType2["SYSTEM"] = 1] = "SYSTEM";
  EmojiType2[EmojiType2["DEFAULT"] = 2] = "DEFAULT";
  return EmojiType2;
})(EmojiType || {});
var RemindType = /* @__PURE__ */ ((RemindType2) => {
  RemindType2["NEVER"] = "0";
  RemindType2["START"] = "1";
  RemindType2["BEFORE_5"] = "2";
  RemindType2["BEFORE_15"] = "3";
  RemindType2["BEFORE_30"] = "4";
  RemindType2["BEFORE_60"] = "5";
  return RemindType2;
})(RemindType || {});
var DeleteHistoryMsgDays = /* @__PURE__ */ ((DeleteHistoryMsgDays2) => {
  DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["ALL"] = -1] = "ALL";
  DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["NONE"] = 0] = "NONE";
  DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["DAY_3"] = 3] = "DAY_3";
  DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["DAY_7"] = 7] = "DAY_7";
  DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["DAY_15"] = 15] = "DAY_15";
  DeleteHistoryMsgDays2[DeleteHistoryMsgDays2["DAY_30"] = 30] = "DAY_30";
  return DeleteHistoryMsgDays2;
})(DeleteHistoryMsgDays || {});
var Forum;
((Forum2) => {
  let AuditType;
  ((AuditType2) => {
    AuditType2[AuditType2["PUBLISH_THREAD"] = 1] = "PUBLISH_THREAD";
    AuditType2[AuditType2["PUBLISH_POST"] = 2] = "PUBLISH_POST";
    AuditType2[AuditType2["PUBLISH_REPLY"] = 3] = "PUBLISH_REPLY";
  })(AuditType = Forum2.AuditType || (Forum2.AuditType = {}));
  let RichType;
  ((RichType2) => {
    RichType2[RichType2["TEXT"] = 1] = "TEXT";
    RichType2[RichType2["AT"] = 2] = "AT";
    RichType2[RichType2["URL"] = 3] = "URL";
    RichType2[RichType2["EMOJI"] = 4] = "EMOJI";
    RichType2[RichType2["CHANNEL"] = 5] = "CHANNEL";
    RichType2[RichType2["VIDEO"] = 10] = "VIDEO";
    RichType2[RichType2["IMAGE"] = 11] = "IMAGE";
  })(RichType = Forum2.RichType || (Forum2.RichType = {}));
  let AtType;
  ((AtType2) => {
    AtType2[AtType2["AT_EXPLICIT_USER"] = 1] = "AT_EXPLICIT_USER";
    AtType2[AtType2["AT_ROLE_GROUP"] = 2] = "AT_ROLE_GROUP";
    AtType2[AtType2["AT_GUILD"] = 3] = "AT_GUILD";
  })(AtType = Forum2.AtType || (Forum2.AtType = {}));
  let ElemType;
  ((ElemType2) => {
    ElemType2[ElemType2["ELEM_TYPE_TEXT"] = 1] = "ELEM_TYPE_TEXT";
    ElemType2[ElemType2["ELEM_TYPE_IMAGE"] = 2] = "ELEM_TYPE_IMAGE";
    ElemType2[ElemType2["ELEM_TYPE_VIDEO"] = 3] = "ELEM_TYPE_VIDEO";
    ElemType2[ElemType2["ELEM_TYPE_URL"] = 4] = "ELEM_TYPE_URL";
  })(ElemType = Forum2.ElemType || (Forum2.ElemType = {}));
  let Alignment;
  ((Alignment2) => {
    Alignment2[Alignment2["ALIGNMENT_LEFT"] = 0] = "ALIGNMENT_LEFT";
    Alignment2[Alignment2["ALIGNMENT_MIDDLE"] = 1] = "ALIGNMENT_MIDDLE";
    Alignment2[Alignment2["ALIGNMENT_RIGHT"] = 2] = "ALIGNMENT_RIGHT";
  })(Alignment || (Alignment = {}));
  let PostFormat;
  ((PostFormat2) => {
    PostFormat2[PostFormat2["FORMAT_TEXT"] = 1] = "FORMAT_TEXT";
    PostFormat2[PostFormat2["FORMAT_HTML"] = 2] = "FORMAT_HTML";
    PostFormat2[PostFormat2["FORMAT_MARKDOWN"] = 3] = "FORMAT_MARKDOWN";
    PostFormat2[PostFormat2["FORMAT_JSON"] = 4] = "FORMAT_JSON";
  })(PostFormat = Forum2.PostFormat || (Forum2.PostFormat = {}));
})(Forum || (Forum = {}));
var ChatType = /* @__PURE__ */ ((ChatType2) => {
  ChatType2[ChatType2["GROUP"] = 1] = "GROUP";
  ChatType2[ChatType2["DIRECT"] = 2] = "DIRECT";
  ChatType2[ChatType2["CHANNEL"] = 3] = "CHANNEL";
  return ChatType2;
})(ChatType || {});

// src/bot/index.ts
var import_core7 = require("@satorijs/core");

// src/ws.ts
var import_core2 = require("@satorijs/core");

// src/utils.ts
var import_core = require("@satorijs/core");
var decodeGuild = /* @__PURE__ */ __name((guild) => ({
  id: guild.id,
  name: guild.name,
  avatar: guild.icon
}), "decodeGuild");
var decodeChannel = /* @__PURE__ */ __name((channel) => ({
  id: channel.id,
  name: channel.name,
  type: channel.type === 0 /* TEXT */ ? import_core.Universal.Channel.Type.TEXT : channel.type === 2 /* VOICE */ ? import_core.Universal.Channel.Type.VOICE : channel.type === 4 /* GROUP */ ? import_core.Universal.Channel.Type.CATEGORY : import_core.Universal.Channel.Type.TEXT,
  parentId: channel.parent_id,
  position: channel.position
}), "decodeChannel");
var decodeUser = /* @__PURE__ */ __name((user) => ({
  id: user.id,
  name: user.username,
  isBot: user.bot,
  avatar: user.avatar
}), "decodeUser");
var decodeGuildMember = /* @__PURE__ */ __name((member) => ({
  user: member.user ? decodeUser(member.user) : void 0,
  nick: member.nick,
  roles: member.roles,
  joinedAt: new Date(member.joined_at).valueOf()
}), "decodeGuildMember");
function decodeGroupMessage(bot, data, message = {}, payload = message) {
  message.id = data.id;
  message.elements = [];
  if (data.content.length) message.elements.push(import_core.h.text(data.content));
  for (const attachment of data.attachments ?? []) {
    if (attachment.content_type === "file") {
      message.elements.push(import_core.h.file(attachment.url, {
        filename: attachment.filename
      }));
    } else if (attachment.content_type.startsWith("image/")) {
      message.elements.push(import_core.h.image(attachment.url));
    } else if (attachment.content_type === "voice") {
      message.elements.push(import_core.h.audio(attachment.url));
    } else if (attachment.content_type === "video") {
      message.elements.push(import_core.h.video(attachment.url));
    }
  }
  message.content = message.elements.join("");
  if (!payload) return message;
  let date = data.timestamp;
  if (date.includes("m=")) {
    date = data.timestamp.slice(0, data.timestamp.indexOf("m=")).trim().replace(/\+(\d{4}) CST/, "GMT+$1");
  }
  payload.timestamp = new Date(date).valueOf();
  payload.guild = data.group_id && { id: data.group_id };
  payload.user = { id: data.author.id, avatar: `https://q.qlogo.cn/qqapp/${bot.config.id}/${data.author.id}/640` };
  return message;
}
__name(decodeGroupMessage, "decodeGroupMessage");
async function decodeMessage(bot, data, message = {}, payload = message) {
  message.id = message.messageId = data.id;
  message.content = (data.content ?? "").replace(/<@!(\d+)>/g, (_, $1) => import_core.h.at($1).toString());
  const { attachments = [] } = data;
  if (attachments.length && !/\s$/.test(message.content)) message.content += " ";
  message.content = attachments.filter(({ content_type }) => content_type.startsWith("image")).reduce((content, attachment) => content + import_core.h.image("https://" + attachment.url), message.content);
  message.elements = import_core.h.parse(message.content);
  message.elements = import_core.h.transform(message.elements, {
    text: /* @__PURE__ */ __name((attrs) => import_core.h.unescape(attrs.content), "text")
  });
  if (data.message_reference) {
    message.quote = bot.getMessage ? await bot.getMessage(data.channel_id, data.message_reference.message_id) : { id: data.message_reference.message_id };
  }
  if (!payload) return message;
  payload.timestamp = new Date(data.timestamp).valueOf();
  payload.user = decodeUser(data.author);
  if (data.direct_message) {
    payload.guild = { id: `${data.src_guild_id}_${data.guild_id}` };
    payload.channel = { id: `${data.guild_id}_${data.channel_id}`, type: import_core.Universal.Channel.Type.DIRECT };
  } else {
    payload.guild = { id: data.guild_id };
    payload.channel = { id: data.channel_id, type: import_core.Universal.Channel.Type.TEXT };
  }
  return message;
}
__name(decodeMessage, "decodeMessage");
function setupReaction(session, data) {
  session.userId = data.user_id;
  session.guildId = data.guild_id;
  session.channelId = data.channel_id;
  session.content = `${data.emoji.type}:${data.emoji.id}`;
  session.messageId = data.target.id;
  session.isDirect = false;
  return session;
}
__name(setupReaction, "setupReaction");
async function adaptSession(bot, input) {
  let session = bot.session();
  if (![
    "GROUP_AT_MESSAGE_CREATE",
    "C2C_MESSAGE_CREATE",
    "FRIEND_ADD",
    "FRIEND_DEL",
    "GROUP_ADD_ROBOT",
    "GROUP_DEL_ROBOT",
    "INTERACTION_CREATE"
  ].includes(input.t)) {
    session = bot.guildBot.session();
    session.setInternal(bot.guildBot.platform, input);
  } else {
    session.setInternal(bot.platform, input);
  }
  if (input.t === "MESSAGE_CREATE" || input.t === "AT_MESSAGE_CREATE" || input.t === "DIRECT_MESSAGE_CREATE") {
    if (bot.config.type === "private" && input.t === "AT_MESSAGE_CREATE" && bot.config.intents & 512 /* GUILD_MESSAGES */) return;
    session.type = "message";
    await decodeMessage(bot, input.d, session.event.message = {}, session.event);
  } else if (input.t === "MESSAGE_REACTION_ADD") {
    if (input.d.target.type !== "ReactionTargetType_MSG") return;
    setupReaction(session, input.d);
    session.type = "reaction-added";
  } else if (input.t === "MESSAGE_REACTION_REMOVE") {
    if (input.d.target.type !== "ReactionTargetType_MSG") return;
    setupReaction(session, input.d);
    session.type = "reaction-removed";
  } else if (input.t === "CHANNEL_CREATE" || input.t === "CHANNEL_UPDATE" || input.t === "CHANNEL_DELETE") {
    session.type = {
      CHANNEL_CREATE: "channel-added",
      CHANNEL_UPDATE: "channel-updated",
      CHANNEL_DELETE: "channel-deleted"
    }[input.t];
    session.guildId = input.d.guild_id;
    session.event.channel = decodeChannel(input.d);
  } else if (input.t === "GUILD_CREATE" || input.t === "GUILD_UPDATE" || input.t === "GUILD_DELETE") {
    session.type = {
      GUILD_CREATE: "guild-added",
      GUILD_UPDATE: "guild-updated",
      GUILD_DELETE: "guild-deleted"
    }[input.t];
    session.event.guild = decodeGuild(input.d);
  } else if (input.t === "DIRECT_MESSAGE_DELETE" || input.t === "MESSAGE_DELETE" || input.t === "PUBLIC_MESSAGE_DELETE") {
    if (bot.config.type === "private" && input.t === "PUBLIC_MESSAGE_DELETE" && bot.config.intents & 512 /* GUILD_MESSAGES */) return;
    session.type = "message-deleted";
    session.userId = input.d.message.author.id;
    session.operatorId = input.d.op_user.id;
    session.messageId = input.d.message.id;
    session.isDirect = input.d.message.direct_message;
    if (session.isDirect) {
      session.guildId = `${input.d.message.src_guild_id}_${input.d.message.guild_id}`;
      session.channelId = `${input.d.message.guild_id}_${input.d.message.channel_id}`;
    } else {
      session.guildId = input.d.message.guild_id;
      session.channelId = input.d.message.channel_id;
    }
  } else if (input.t === "GROUP_AT_MESSAGE_CREATE") {
    session.type = "message";
    session.isDirect = false;
    decodeGroupMessage(bot, input.d, session.event.message = {}, session.event);
    session.channelId = session.guildId;
    session.elements.unshift(import_core.h.at(session.selfId));
  } else if (input.t === "C2C_MESSAGE_CREATE") {
    session.type = "message";
    session.isDirect = true;
    decodeGroupMessage(bot, input.d, session.event.message = {}, session.event);
    session.channelId = session.userId;
  } else if (input.t === "FRIEND_ADD") {
    session.type = "friend-added";
    session.timestamp = input.d.timestamp;
    session.userId = input.d.openid;
  } else if (input.t === "FRIEND_DEL") {
    session.type = "friend-deleted";
    session.timestamp = input.d.timestamp;
    session.userId = input.d.openid;
  } else if (input.t === "GROUP_ADD_ROBOT") {
    session.type = "guild-added";
    session.timestamp = input.d.timestamp;
    session.guildId = input.d.group_openid;
    session.operatorId = input.d.op_member_openid;
  } else if (input.t === "GROUP_DEL_ROBOT") {
    session.type = "guild-removed";
    session.timestamp = input.d.timestamp;
    session.guildId = input.d.group_openid;
    session.operatorId = input.d.op_member_openid;
  } else if (input.t === "INTERACTION_CREATE") {
    session.type = "interaction/button";
    session.userId = input.d.group_member_openid ?? input.d.user_openid ?? input.d.data.resolved.user_id;
    if (input.d.chat_type === 1 /* GROUP */) {
      session.guildId = input.d.group_openid;
      session.channelId = input.d.group_openid;
      session.isDirect = false;
    } else if (input.d.chat_type === 3 /* CHANNEL */) {
      session.channelId = input.d.channel_id;
      session.isDirect = false;
    } else if (input.d.chat_type === 2 /* DIRECT */) {
      session.isDirect = true;
      session.channelId = session.userId;
    }
    session.event.button = {
      id: input.d.data.resolved.button_id,
      // @ts-ignore
      data: input.d.data.resolved.button_data
    };
    if (!bot.config.manualAcknowledge) bot.internal.acknowledgeInteraction(input.d.id, { code: 0 }).catch(() => {
    });
  } else if (input.t === "GUILD_MEMBER_ADD" || input.t === "GUILD_MEMBER_DELETE" || input.t === "GUILD_MEMBER_UPDATE") {
    session.type = {
      GUILD_MEMBER_ADD: "guild-member-added",
      GUILD_MEMBER_UPDATE: "guild-member-updated",
      GUILD_MEMBER_DELETE: "guild-member-removed"
    }[input.t];
    session.guildId = input.d.guild_id;
    session.operatorId = input.d.op_user_id;
    session.timestamp = Date.now();
    session.event.user = decodeUser(input.d.user);
  } else {
    return;
  }
  return session;
}
__name(adaptSession, "adaptSession");

// src/ws.ts
var WsClient = class extends import_core2.Adapter.WsClient {
  static {
    __name(this, "WsClient");
  }
  _sessionId = "";
  _s = null;
  _ping;
  _acked = true;
  async prepare() {
    if (this.bot.config.authType === "bearer") await this.bot.getAccessToken();
    try {
      const url = this.bot.config.gatewayUrl ? this.bot.config.gatewayUrl : (await this.bot.internal.getGateway()).url.replace("api.sgroup.qq.com", new URL(this.bot.config.endpoint).host);
      this.bot.logger.debug("url: %s", url);
      return this.bot.http.ws(url);
    } catch (error) {
      if (this.bot.http.isError(error) && error.response) {
        this.bot.logger.warn(`GET /gateway response: %o`, error.response.data);
      }
      throw error;
    }
  }
  heartbeat() {
    if (!this._acked) {
      this.bot.logger.warn("zombied connection");
      return this.socket.close();
    }
    this.socket.send(JSON.stringify({
      op: 1 /* HEARTBEAT */,
      s: this._s
    }));
    this._acked = false;
  }
  async accept() {
    this.socket.addEventListener("message", async ({ data }) => {
      const parsed = JSON.parse(data.toString());
      this.bot.logger.debug("websocket receives %o", parsed);
      if (parsed.op === 10 /* HELLO */) {
        const token = this.bot.config.authType === "bearer" ? `QQBot ${await this.bot.getAccessToken()}` : `Bot ${this.bot.config.id}.${this.bot.config.token}`;
        if (this._sessionId) {
          this.socket.send(JSON.stringify({
            op: 6 /* RESUME */,
            d: {
              token,
              session_id: this._sessionId,
              seq: this._s
            }
          }));
        } else {
          this.socket.send(JSON.stringify({
            op: 2 /* IDENTIFY */,
            d: {
              token,
              intents: this.bot.config.intents,
              shard: [0, 1]
            }
          }));
        }
        this._ping = setInterval(() => this.heartbeat(), parsed.d.heartbeat_interval);
      } else if (parsed.op === 11 /* HEARTBEAT_ACK */) {
        this._acked = true;
      } else if (parsed.op === 9 /* INVALID_SESSION */) {
        this._sessionId = "";
        this._s = null;
        this.bot.logger.warn("offline: invalid session");
      } else if (parsed.op === 7 /* RECONNECT */) {
        this.bot.logger.warn("offline: server request reconnect");
      } else if (parsed.op === 0 /* DISPATCH */) {
        this.bot.dispatch(this.bot.session({
          type: "internal",
          _type: "qq/" + parsed.t.toLowerCase().replace(/_/g, "-"),
          _data: parsed.d
        }));
        this._s = parsed.s;
        if (parsed.t === "READY") {
          this._sessionId = parsed.d.session_id;
          this.bot.user = decodeUser(parsed.d.user);
          this.bot.guildBot.user = this.bot.user;
          try {
            await this.bot.initialize();
          } catch (e) {
            this.bot.logger.warn(e);
          }
          return this.bot.online();
        }
        if (parsed.t === "RESUMED") {
          return this.bot.online();
        }
        const session = await adaptSession(this.bot, parsed);
        if (session) this.bot.dispatch(session);
      }
    });
    this.socket.addEventListener("close", (e) => {
      this.bot.logger.debug("websocket closed, code %o, reason: %s", e.code, e.reason);
      if (e.code > 4e3 && ![4008, 4009].includes(e.code)) {
        this._sessionId = "";
        this._s = null;
      }
      clearInterval(this._ping);
    });
  }
};
((WsClient2) => {
  WsClient2.Options = import_core2.Schema.intersect([
    import_core2.Schema.object({
      protocol: import_core2.Schema.const("websocket").required(false)
    }),
    import_core2.Adapter.WsClientConfig
  ]);
})(WsClient || (WsClient = {}));

// src/bot/guild.ts
var import_core5 = require("@satorijs/core");

// src/internal/internal.ts
var import_core3 = require("@satorijs/core");
var Internal = class {
  constructor(bot, http) {
    this.bot = bot;
    this.http = http;
  }
  static {
    __name(this, "Internal");
  }
  static define(isGuild, routes, preset) {
    for (const path in routes) {
      for (const key in routes[path]) {
        const method = key;
        for (const name of (0, import_core3.makeArray)(routes[path][method])) {
          (isGuild ? GuildInternal : GroupInternal).prototype[name] = async function(...args) {
            const raw = args.join(", ");
            const url = path.replace(/\{([^}]+)\}/g, () => {
              if (!args.length) throw new Error(`too few arguments for ${path}, received ${raw}`);
              return args.shift();
            });
            const config = { ...preset };
            if (args.length === 1) {
              if (method === "GET" || method === "DELETE") {
                config.params = args[0];
              } else {
                config.data = args[0];
              }
            } else if (args.length === 2 && method !== "GET" && method !== "DELETE") {
              config.data = args[0];
              config.params = args[1];
            } else if (args.length > 1) {
              throw new Error(`too many arguments for ${path}, received ${raw}`);
            }
            const http = this.http();
            try {
              this.bot.logger.debug(`${method} ${url} request: %o`, config);
              const response = await http(url, { ...config, method });
              this.bot.logger.debug(`${method} ${url} response: %o, trace id: %s`, response.data, response.headers.get("x-tps-trace-id"));
              return response.data;
            } catch (error) {
              if (!http.isError(error) || !error.response) throw error;
              this.bot.logger.debug(`${method} ${url} response: %o, trace id: %s`, error.response.data, error.response.headers.get("x-tps-trace-id"));
              throw error;
            }
          };
        }
      }
    }
  }
};
var GroupInternal = class extends Internal {
  static {
    __name(this, "GroupInternal");
  }
};
var GuildInternal = class extends Internal {
  static {
    __name(this, "GuildInternal");
  }
};

// src/internal/group.ts
GroupInternal.define(false, {
  "/v2/groups/{channel.id}/messages": {
    POST: "sendMessage"
  },
  "/v2/groups/{channel.id}/messages/{message.id}": {
    DELETE: "deleteMessage"
  },
  "/v2/users/{user.id}/messages": {
    POST: "sendPrivateMessage"
  },
  "/v2/users/{user.id}/messages/{message.id}": {
    DELETE: "deletePrivateMessage"
  },
  "/v2/users/{user.id}/files": {
    POST: "sendFilePrivate"
  },
  "/v2/groups/{channel.id}/files": {
    POST: "sendFileGuild"
  },
  "/gateway": {
    GET: "getGateway"
  },
  "/gateway/bot": {
    GET: "getGatewayBot"
  }
});
GroupInternal.define(false, {
  "/interactions/{interaction.id}": {
    PUT: "acknowledgeInteraction"
  }
}, { responseType: "text" });

// src/internal/guild.ts
GuildInternal.define(true, {
  "/users/@me": {
    GET: "getMe"
  },
  "/users/@me/guilds": {
    GET: "getGuilds"
  },
  "/guilds/{guild.id}": {
    GET: "getGuild"
  },
  "/guilds/{guild.id}/channels": {
    GET: "getChannels",
    POST: "createGuildChannel"
  },
  "/channels/{channel.id}": {
    GET: "getChannel",
    PATCH: "modifyChannel",
    DELETE: "deleteChannel"
  },
  "/channels/{channel.id}/online_nums": {
    GET: "getChannelOnlineNums"
  },
  "/guilds/{guild.id}/members": {
    GET: "getGuildMembers"
  },
  "/guilds/{guild.id}/roles/{role.id}/members": {
    GET: "getGuildRoleMembers"
  },
  "/guilds/{guild.id}/members/{user.id}": {
    GET: "getGuildMember",
    DELETE: "removeGuildMember"
  },
  "/guilds/{guild.id}/roles": {
    GET: "getGuildRoles",
    POST: "createGuildRole"
  },
  "/guilds/{guild.id}/roles/{role.id}": {
    PATCH: "modifyGuildRole",
    DELETE: "removeGuildRole"
  },
  "/guilds/{guild.id}/members/{user.id}/roles/{role.id}": {
    PUT: "addGuildMemberRole",
    DELETE: "removeGuildMemberRole"
  },
  "/channels/{channel.id}/members/{user.id}/permissions": {
    GET: "getChannelMemberPermissions",
    PUT: "modifyChannelMemberPermissions"
  },
  "/channels/{channel.id}/roles/{role.id}/permissions": {
    GET: "getChannelRole",
    PUT: "modifyChannelRole"
  },
  "/channels/{channel.id}/messages/{message.id}": {
    GET: "getMessage",
    DELETE: "deleteMessage"
  },
  "/channels/{channel.id}/messages": {
    POST: "sendMessage"
  },
  "/dms/{guild.id}/messages": {
    POST: "sendDM"
  },
  "/guilds/{guild.id}/messages/setting": {
    GET: "getMessageSetting"
  },
  "/users/@me/dms": {
    POST: "createDMS"
  },
  "/dms/{guild.id}/messages/{message.id}": {
    DELETE: "deleteDM"
  },
  "/guilds/{guild.id}/mute": {
    PATCH: "muteGuildOrMembers"
  },
  "/guilds/{guild.id}/members/{user.id}/mute": {
    PATCH: "muteGuildMember"
  },
  "/guilds/{guild.id}/announces": {
    POST: "createGuildAnnounce"
  },
  "/guilds/{guild.id}/announces/{message.id}": {
    DELETE: "removeGuildAnnounce"
  },
  "/channels/{channel.id}/pins/{message.id}": {
    PUT: "createPinsMessage",
    DELETE: "removePinsMessage"
  },
  "/channels/{channel.id}/pins": {
    GET: "getPinsMessage"
  },
  "/channels/{channel.id}/schedules": {
    GET: "getSchedules",
    POST: "createSchedule"
  },
  "/channels/{channel.id}/schedules/{schedule.id}": {
    GET: "getSchedule",
    PATCH: "modifySchedule",
    DELETE: "removeSchedule"
  },
  "/channels/{channel.id}/messages/{message.id}/reactions/{type}/{id}": {
    PUT: "createReaction",
    DELETE: "deleteReaction",
    GET: "getReactions"
  },
  "/channels/{channel.id}/threads": {
    GET: "listThreads",
    PUT: "createPost"
  },
  "/channels/{channel.id}/threads/{thread.id}": {
    DELETE: "removePost"
  },
  "/guilds/{guild.id}/api_permissions": {
    GET: "getGuildApiPermissions"
  },
  "/guilds/{guild.id}/api_permissions/demand": {
    POST: "createGuildApiPermissionDemand"
  }
});

// src/message.ts
var import_core4 = require("@satorijs/core");
var escapeMarkdown = /* @__PURE__ */ __name((val) => val.replace(/([\\`*_[\*_~`\]\-(#!>])/g, "\\$&"), "escapeMarkdown");
var QQGuildMessageEncoder = class extends import_core4.MessageEncoder {
  static {
    __name(this, "QQGuildMessageEncoder");
  }
  content = "";
  file;
  filename;
  fileUrl;
  passiveId;
  passiveEventId;
  reference;
  retry = false;
  // 先文后图
  async flush() {
    if (!this.content.trim().length && !this.file && !this.fileUrl) {
      return;
    }
    const isDirect = this.channelId.includes("_");
    let endpoint = `/channels/${this.channelId}/messages`;
    if (isDirect) endpoint = `/dms/${this.channelId.split("_")[0]}/messages`;
    const useFormData = Boolean(this.file);
    let msg_id = this.options?.session?.messageId;
    if (this.options?.session && Date.now() - this.options?.session?.timestamp > MSG_TIMEOUT) {
      msg_id = null;
    }
    if (this.passiveId) msg_id = this.passiveId;
    let r;
    this.bot.logger.debug("use form data %s", useFormData);
    try {
      if (useFormData) {
        const form = new FormData();
        form.append("content", this.content);
        if (this.options?.session && msg_id) {
          form.append("msg_id", msg_id);
        }
        if (this.passiveEventId) {
          form.append("event_id", this.passiveEventId);
        }
        if (this.file) {
          form.append("file_image", this.file, this.filename);
        }
        r = await this.bot.http.post(endpoint, form);
      } else {
        const payload = {
          ...{
            content: this.content,
            msg_id,
            image: this.fileUrl
          },
          ...this.reference ? {
            message_reference: {
              message_id: this.reference
            }
          } : {},
          ...this.passiveEventId ? {
            event_id: this.passiveEventId
          } : {}
        };
        if (isDirect) r = await this.bot.internal.sendDM(this.channelId.split("_")[0], payload);
        else r = await this.bot.internal.sendMessage(this.channelId, payload);
      }
    } catch (e) {
      if (this.bot.http.isError(e)) {
        if (this.bot.parent.config.retryWhen.includes(e.response.data.code) && !this.retry && this.fileUrl) {
          this.bot.logger.warn("retry image sending");
          this.retry = true;
          await this.resolveFile(null, true);
          await this.flush();
        }
        if (useFormData) {
          this.bot.logger.warn(`POST ${endpoint} response: %o, trace id: %s`, e.response.data, e.response.headers.get("x-tps-trace-id"));
        }
      }
    }
    const session = this.bot.session();
    session.type = "send";
    session.guildId = this.session.guildId;
    session.channelId = this.channelId;
    session.isDirect = isDirect;
    if (r?.id) {
      session.messageId = r.id;
      session.app.emit(session, "send", session);
      this.results.push(session.event.message);
    } else if (r?.code === 304023 && this.bot.config.parent.intents & 134217728 /* MESSAGE_AUDIT */) {
      try {
        const auditData = await this.audit(r.data.message_audit.audit_id);
        session.messageId = auditData.message_id;
        session.app.emit(session, "send", session);
        this.results.push(session.event.message);
      } catch (e) {
        this.bot.logger.error(e);
      }
    }
    this.content = "";
    this.file = null;
    this.filename = null;
    this.fileUrl = null;
    this.retry = false;
  }
  async audit(audit_id) {
    return new Promise((resolve, reject) => {
      const dispose = this.bot.ctx.on("qq/message-audit-pass", (data) => {
        if (data.audit_id === audit_id) {
          dispose();
          dispose2();
          resolve(data);
        }
      });
      const dispose2 = this.bot.ctx.on("qq/message-audit-reject", (data) => {
        if (data.audit_id === audit_id) {
          dispose();
          dispose2();
          reject(data);
        }
      });
    });
  }
  async resolveFile(attrs, download = false) {
    if (!download && !await this.bot.ctx.http.isLocal(attrs.src || attrs.url)) {
      return this.fileUrl = attrs.src || attrs.url;
    }
    const { data, filename, type } = await this.bot.ctx.http.file(this.fileUrl || attrs.src || attrs.url, attrs);
    this.file = new Blob([data], { type });
    this.filename = filename;
    this.fileUrl = null;
  }
  async visit(element) {
    const { type, attrs, children } = element;
    if (type === "text") {
      this.content += attrs.content;
    } else if (type === "at") {
      switch (attrs.type) {
        case "all":
          this.content += `@everyone`;
          break;
        default:
          this.content += `<@${attrs.id}>`;
      }
    } else if (type === "br") {
      this.content += "\n";
    } else if (type === "p") {
      if (!this.content.endsWith("\n")) this.content += "\n";
      await this.render(children);
      if (!this.content.endsWith("\n")) this.content += "\n";
    } else if (type === "sharp") {
      this.content += `<#${attrs.id}>`;
    } else if (type === "quote") {
      this.reference = attrs.id;
      await this.flush();
    } else if (type === "passive") {
      if (attrs.messageId) this.passiveId = attrs.messageId;
      if (attrs.eventId) this.passiveEventId = attrs.eventId;
    } else if ((type === "img" || type === "image") && (attrs.src || attrs.url)) {
      await this.flush();
      await this.resolveFile(attrs);
      await this.flush();
    } else if (type === "message") {
      await this.flush();
      await this.render(children);
      await this.flush();
    } else {
      await this.render(children);
    }
  }
};
var MSG_TIMEOUT = 5 * 60 * 1e3 - 2e3;
var QQMessageEncoder = class extends import_core4.MessageEncoder {
  static {
    __name(this, "QQMessageEncoder");
  }
  content = "";
  passiveId;
  passiveSeq;
  passiveEventId;
  useMarkdown = false;
  rows = [];
  attachedFile;
  retry = false;
  // 先图后文
  async flush() {
    if (!this.content.trim() && !this.rows.flat().length && !this.attachedFile) return;
    this.trimButtons();
    let msg_id, msg_seq, event_id;
    if (this.options?.session?.messageId && Date.now() - this.options.session.timestamp < MSG_TIMEOUT) {
      this.options.session["seq"] ||= 0;
      msg_id = this.options.session.messageId;
      msg_seq = ++this.options.session["seq"];
    } else if (this.options?.session?.qq["id"] && Date.now() - this.options.session.timestamp < MSG_TIMEOUT) {
      event_id = this.options.session.qq["id"];
    }
    if (this.passiveId) msg_id = this.passiveId;
    if (this.passiveSeq) msg_seq = this.passiveSeq;
    if (this.passiveEventId) event_id = this.passiveEventId;
    const data = {
      content: this.content,
      msg_type: Message.Type.TEXT,
      msg_id,
      msg_seq,
      event_id
    };
    if (this.attachedFile) {
      if (!data.content.length) data.content = " ";
      data.media = this.attachedFile;
      data.msg_type = Message.Type.MEDIA;
    }
    if (this.useMarkdown) {
      data.msg_type = Message.Type.MARKDOWN;
      delete data.content;
      data.markdown = {
        content: escapeMarkdown(this.content) || " "
      };
      if (this.rows.length) {
        data.keyboard = {
          content: {
            rows: this.exportButtons()
          }
        };
      }
    }
    const session = this.bot.session();
    session.type = "send";
    const send = /* @__PURE__ */ __name(async () => {
      try {
        const resp = this.session.isDirect ? await this.bot.internal.sendPrivateMessage(this.session.channelId, data) : await this.bot.internal.sendMessage(this.session.channelId, data);
        if (resp.id && !resp.audit_id) {
          session.messageId = resp.id;
          session.timestamp = new Date(resp.timestamp).valueOf();
          session.channelId = this.session.channelId;
          session.guildId = this.session.guildId;
          session.app.emit(session, "send", session);
          this.results.push(session.event.message);
        } else if (resp.audit_id && this.bot.config.intents & 134217728 /* MESSAGE_AUDIT */) {
          try {
            const auditData = await this.audit(resp.audit_id);
            session.messageId = auditData.message_id;
            session.app.emit(session, "send", session);
            this.results.push(session.event.message);
          } catch (e) {
            this.bot.logger.error(e);
          }
        }
      } catch (e) {
        if (!this.bot.http.isError(e)) throw e;
        this.errors.push(e);
        if (!this.retry && this.bot.config.retryWhen.includes(e.response.data.code)) {
          this.bot.logger.warn("%s retry message sending", this.session.cid);
          this.retry = true;
          await send();
        }
      }
    }, "send");
    await send();
    this.content = "";
    this.attachedFile = null;
    this.rows = [];
    this.retry = false;
  }
  async audit(audit_id) {
    return new Promise((resolve, reject) => {
      const dispose = this.bot.ctx.on("qq/message-audit-pass", (data) => {
        if (data.audit_id === audit_id) {
          dispose();
          dispose2();
          resolve(data);
        }
      });
      const dispose2 = this.bot.ctx.on("qq/message-audit-reject", (data) => {
        if (data.audit_id === audit_id) {
          dispose();
          dispose2();
          reject(data);
        }
      });
    });
  }
  async sendFile(type, attrs) {
    const url = attrs.src || attrs.url;
    let file_type = 0;
    if (type === "img" || type === "image") file_type = 1;
    else if (type === "video") file_type = 2;
    else if (type === "audio") file_type = 3;
    else return;
    const data = {
      file_type,
      srv_send_msg: false
    };
    const capture = /^data:([\w/.+-]+);base64,(.*)$/.exec(url);
    if (capture?.[2]) {
      data.file_data = capture[2];
    } else if (await this.bot.ctx.http.isLocal(url)) {
      data.file_data = Buffer.from((await this.bot.ctx.http.file(url)).data).toString("base64");
    } else {
      data.url = url;
    }
    let res;
    try {
      if (this.session.isDirect) {
        res = await this.bot.internal.sendFilePrivate(this.options.session.userId, data);
      } else {
        res = await this.bot.internal.sendFileGuild(this.session.channelId, data);
      }
    } catch (e) {
      if (!this.bot.http.isError(e)) throw e;
      this.errors.push(e);
      if (!this.retry && this.bot.config.retryWhen.includes(e.response.data.code)) {
        this.bot.logger.warn("%s retry message sending", this.session.cid);
        this.retry = true;
        await this.sendFile(type, attrs);
      }
    }
    this.retry = false;
    return res;
  }
  decodeButton(attrs, label) {
    const result = {
      id: attrs.id,
      render_data: {
        label,
        visited_label: label,
        style: attrs.class === "primary" ? 1 : 0
      },
      action: {
        type: attrs.type === "input" ? 2 : attrs.type === "link" ? 0 : 1,
        permission: {
          type: 2
        },
        data: attrs.type === "input" ? attrs.text : attrs.type === "link" ? attrs.href : attrs.id
      }
    };
    return result;
  }
  lastRow() {
    if (!this.rows.length) this.rows.push([]);
    let last = this.rows[this.rows.length - 1];
    if (last.length >= 5) {
      this.rows.push([]);
      last = this.rows[this.rows.length - 1];
    }
    return last;
  }
  trimButtons() {
    if (this.rows.length && this.rows[this.rows.length - 1].length === 0) this.rows.pop();
  }
  exportButtons() {
    return this.rows.map((v) => ({
      buttons: v
    }));
  }
  async visit(element) {
    const { type, attrs, children } = element;
    if (type === "text") {
      this.content += attrs.content;
    } else if (type === "passive") {
      if (attrs.messageId) this.passiveId = attrs.messageId;
      if (attrs.seq) this.passiveSeq = Number(attrs.seq);
      if (attrs.eventId) this.passiveEventId = attrs.eventId;
    } else if ((type === "img" || type === "image") && (attrs.src || attrs.url)) {
      await this.flush();
      const data = await this.sendFile(type, attrs);
      if (data) this.attachedFile = data;
    } else if (type === "video" && (attrs.src || attrs.url)) {
      await this.flush();
      const data = await this.sendFile(type, attrs);
      if (data) this.attachedFile = data;
      await this.flush();
    } else if (type === "audio" && (attrs.src || attrs.url)) {
      await this.flush();
      const { data } = await this.bot.ctx.http.file(attrs.src || attrs.url, attrs);
      if (new TextDecoder().decode(data.slice(0, 7)).includes("#!SILK")) {
        const onlineFile = await this.sendFile(type, {
          src: `data:audio/amr;base64,` + Buffer.from(data).toString("base64")
        });
        this.attachedFile = onlineFile;
      } else {
        const ntsilk = this.bot.ctx.get("ntsilk");
        if (ntsilk) {
          const result = await ntsilk.encode(data);
          const onlineFile = await this.sendFile(type, {
            src: `data:audio/amr;base64,` + result.output.toString("base64")
          });
          if (onlineFile) this.attachedFile = onlineFile;
        } else {
          const silk = this.bot.ctx.get("silk");
          if (!silk) return this.bot.logger.warn("missing ntsilk/silk service, cannot send non-silk audio");
          const allowSampleRate = [8e3, 12e3, 16e3, 24e3, 32e3, 44100, 48e3];
          if (silk.isWav(data) && allowSampleRate.includes(silk.getWavFileInfo(data).fmt.sampleRate)) {
            const result = await silk.encode(data, 0);
            const onlineFile = await this.sendFile(type, {
              src: `data:audio/amr;base64,` + Buffer.from(result.data).toString("base64")
            });
            if (onlineFile) this.attachedFile = onlineFile;
          } else {
            if (!this.bot.ctx.get("ffmpeg")) return this.bot.logger.warn("missing ffmpeg service, cannot send non-silk audio except some wav");
            const pcmBuf = await this.bot.ctx.get("ffmpeg").builder().input(Buffer.from(data)).outputOption("-ar", "24000", "-ac", "1", "-f", "s16le").run("buffer");
            const result = await silk.encode(pcmBuf, 24e3);
            const onlineFile = await this.sendFile(type, {
              src: `data:audio/amr;base64,` + Buffer.from(result.data).toString("base64")
            });
            if (onlineFile) this.attachedFile = onlineFile;
          }
        }
      }
      await this.flush();
    } else if (type === "br") {
      this.content += "\n";
    } else if (type === "p") {
      if (!this.content.endsWith("\n")) this.content += "\n";
      await this.render(children);
      if (!this.content.endsWith("\n")) this.content += "\n";
    } else if (type === "button-group") {
      this.useMarkdown = true;
      this.rows.push([]);
      await this.render(children);
      this.rows.push([]);
    } else if (type === "button") {
      this.useMarkdown = true;
      const last = this.lastRow();
      last.push(this.decodeButton(attrs, children.join("")));
    } else if (type === "message") {
      await this.flush();
      await this.render(children);
      await this.flush();
    } else {
      await this.render(children);
    }
  }
};

// src/bot/guild.ts
var QQGuildBot = class extends import_core5.Bot {
  static {
    __name(this, "QQGuildBot");
  }
  hidden = true;
  internal;
  http;
  static MessageEncoder = QQGuildMessageEncoder;
  constructor(ctx, config) {
    super(ctx, config, "qq");
    this.parent = config.parent;
    this.parent.guildBot = this;
    this.platform = "qqguild";
    this.internal = new GuildInternal(this, () => config.parent.http);
    this.http = config.parent.http;
  }
  get status() {
    return this.parent.status;
  }
  set status(status) {
    this.parent.status = status;
  }
  async getUser(userId, guildId) {
    const { user } = await this.getGuildMember(guildId, userId);
    return user;
  }
  async getGuildList(next) {
    const guilds = await this.internal.getGuilds();
    return { data: guilds.map(decodeGuild) };
  }
  async getGuild(guildId) {
    const guild = await this.internal.getGuild(guildId);
    return decodeGuild(guild);
  }
  async getChannelList(guildId, next) {
    const channels = await this.internal.getChannels(guildId);
    return { data: channels.map(decodeChannel) };
  }
  async getChannel(channelId) {
    const channel = await this.internal.getChannel(channelId);
    return decodeChannel(channel);
  }
  async createChannel(guildId, data) {
    const channel = await this.internal.createGuildChannel(guildId, {
      name: data.name,
      type: data.type === import_core5.Universal.Channel.Type.TEXT ? 0 /* TEXT */ : data.type === import_core5.Universal.Channel.Type.CATEGORY ? 4 /* GROUP */ : data.type === import_core5.Universal.Channel.Type.VOICE ? 2 /* VOICE */ : 0 /* TEXT */,
      parent_id: data.parentId,
      position: data.position,
      sub_type: 0,
      private_type: 0,
      speak_permission: 1,
      private_user_ids: []
    });
    return decodeChannel(channel);
  }
  async getGuildMemberList(guildId, next) {
    const members = await this.internal.getGuildMembers(guildId, {
      limit: 400,
      after: next
    });
    return { data: members.map(decodeGuildMember), next: members[members.length - 1].user.id };
  }
  async getGuildMember(guildId, userId) {
    const member = await this.internal.getGuildMember(guildId, userId);
    return decodeGuildMember(member);
  }
  async kickGuildMember(guildId, userId) {
    await this.internal.removeGuildMember(guildId, userId);
  }
  async muteGuildMember(guildId, userId, duration) {
    await this.internal.muteGuildMember(guildId, userId, {
      mute_seconds: Math.floor(duration / 1e3)
    });
  }
  async getReactionList(channelId, messageId, emoji, next) {
    const [type, id] = emoji.split(":");
    const { users, cookie } = await this.internal.getReactions(channelId, messageId, type, id, {
      limit: 50,
      cookie: next
    });
    return { next: cookie, data: users.map(decodeUser) };
  }
  async createReaction(channelId, messageId, emoji) {
    const [type, id] = emoji.split(":");
    await this.internal.createReaction(channelId, messageId, type, id);
  }
  async deleteReaction(channelId, messageId, emoji) {
    const [type, id] = emoji.split(":");
    await this.internal.deleteReaction(channelId, messageId, type, id);
  }
  async getMessage(channelId, messageId) {
    const r = await this.internal.getMessage(channelId, messageId);
    return decodeMessage(this, r.message);
  }
  async deleteMessage(channelId, messageId) {
    if (channelId.includes("_")) {
      const [guildId] = channelId.split("_");
      await this.internal.deleteDM(guildId, messageId);
    } else {
      await this.internal.deleteMessage(channelId, messageId);
    }
  }
  async getLogin() {
    return this.parent.getLogin();
  }
  async createDirectChannel(id, guild_id) {
    let input_guild_id = guild_id;
    if (guild_id?.includes("_")) input_guild_id = guild_id.split("_")[0];
    const dms = await this.internal.createDMS({
      recipient_id: id,
      source_guild_id: input_guild_id
    });
    return { id: `${dms.guild_id}_${input_guild_id}`, type: import_core5.Universal.Channel.Type.DIRECT };
  }
};

// src/http.ts
var import_core6 = require("@satorijs/core");

// ../../../../node_modules/@noble/ed25519/index.js
var ed25519_CURVE = {
  p: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,
  n: 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,
  h: 8n,
  a: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,
  d: 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,
  Gx: 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,
  Gy: 0x6666666666666666666666666666666666666666666666666666666666666658n
};
var { p: P, n: N, Gx, Gy, a: _a, d: _d } = ed25519_CURVE;
var h3 = 8n;
var L = 32;
var L2 = 64;
var err = /* @__PURE__ */ __name((m = "") => {
  throw new Error(m);
}, "err");
var isBig = /* @__PURE__ */ __name((n) => typeof n === "bigint", "isBig");
var isStr = /* @__PURE__ */ __name((s) => typeof s === "string", "isStr");
var isBytes = /* @__PURE__ */ __name((a) => a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array", "isBytes");
var abytes = /* @__PURE__ */ __name((a, l) => !isBytes(a) || typeof l === "number" && l > 0 && a.length !== l ? err("Uint8Array expected") : a, "abytes");
var u8n = /* @__PURE__ */ __name((len) => new Uint8Array(len), "u8n");
var u8fr = /* @__PURE__ */ __name((buf) => Uint8Array.from(buf), "u8fr");
var padh = /* @__PURE__ */ __name((n, pad) => n.toString(16).padStart(pad, "0"), "padh");
var bytesToHex = /* @__PURE__ */ __name((b) => Array.from(abytes(b)).map((e) => padh(e, 2)).join(""), "bytesToHex");
var C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
var _ch = /* @__PURE__ */ __name((ch) => {
  if (ch >= C._0 && ch <= C._9)
    return ch - C._0;
  if (ch >= C.A && ch <= C.F)
    return ch - (C.A - 10);
  if (ch >= C.a && ch <= C.f)
    return ch - (C.a - 10);
  return;
}, "_ch");
var hexToBytes = /* @__PURE__ */ __name((hex) => {
  const e = "hex invalid";
  if (!isStr(hex))
    return err(e);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    return err(e);
  const array = u8n(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = _ch(hex.charCodeAt(hi));
    const n2 = _ch(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0)
      return err(e);
    array[ai] = n1 * 16 + n2;
  }
  return array;
}, "hexToBytes");
var toU8 = /* @__PURE__ */ __name((a, len) => abytes(isStr(a) ? hexToBytes(a) : u8fr(abytes(a)), len), "toU8");
var cr = /* @__PURE__ */ __name(() => globalThis?.crypto, "cr");
var subtle = /* @__PURE__ */ __name(() => cr()?.subtle ?? err("crypto.subtle must be defined"), "subtle");
var concatBytes = /* @__PURE__ */ __name((...arrs) => {
  const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}, "concatBytes");
var randomBytes = /* @__PURE__ */ __name((len = L) => {
  const c = cr();
  return c.getRandomValues(u8n(len));
}, "randomBytes");
var big = BigInt;
var arange = /* @__PURE__ */ __name((n, min, max, msg = "bad number: out of range") => isBig(n) && min <= n && n < max ? n : err(msg), "arange");
var M = /* @__PURE__ */ __name((a, b = P) => {
  const r = a % b;
  return r >= 0n ? r : b + r;
}, "M");
var modN = /* @__PURE__ */ __name((a) => M(a, N), "modN");
var invert = /* @__PURE__ */ __name((num, md) => {
  if (num === 0n || md <= 0n)
    err("no inverse n=" + num + " mod=" + md);
  let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;
  while (a !== 0n) {
    const q = b / a, r = b % a;
    const m = x - u * q, n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  return b === 1n ? M(x, md) : err("no inverse");
}, "invert");
var apoint = /* @__PURE__ */ __name((p) => p instanceof Point ? p : err("Point expected"), "apoint");
var B256 = 2n ** 256n;
var Point = class _Point {
  static {
    __name(this, "Point");
  }
  static BASE;
  static ZERO;
  ex;
  ey;
  ez;
  et;
  constructor(ex, ey, ez, et) {
    const max = B256;
    this.ex = arange(ex, 0n, max);
    this.ey = arange(ey, 0n, max);
    this.ez = arange(ez, 1n, max);
    this.et = arange(et, 0n, max);
    Object.freeze(this);
  }
  static fromAffine(p) {
    return new _Point(p.x, p.y, 1n, M(p.x * p.y));
  }
  /** RFC8032 5.1.3: Uint8Array to Point. */
  static fromBytes(hex, zip215 = false) {
    const d = _d;
    const normed = u8fr(abytes(hex, L));
    const lastByte = hex[31];
    normed[31] = lastByte & ~128;
    const y = bytesToNumLE(normed);
    const max = zip215 ? B256 : P;
    arange(y, 0n, max);
    const y2 = M(y * y);
    const u = M(y2 - 1n);
    const v = M(d * y2 + 1n);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      err("bad point: y not sqrt");
    const isXOdd = (x & 1n) === 1n;
    const isLastByteOdd = (lastByte & 128) !== 0;
    if (!zip215 && x === 0n && isLastByteOdd)
      err("bad point: x==0, isLastByteOdd");
    if (isLastByteOdd !== isXOdd)
      x = M(-x);
    return new _Point(x, y, 1n, M(x * y));
  }
  /** Checks if the point is valid and on-curve. */
  assertValidity() {
    const a = _a;
    const d = _d;
    const p = this;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X2 = M(X * X);
    const Y2 = M(Y * Y);
    const Z2 = M(Z * Z);
    const Z4 = M(Z2 * Z2);
    const aX2 = M(X2 * a);
    const left = M(Z2 * M(aX2 + Y2));
    const right = M(Z4 + M(d * M(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = M(X * Y);
    const ZT = M(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return this;
  }
  /** Equality check: compare points P&Q. */
  equals(other) {
    const { ex: X1, ey: Y1, ez: Z1 } = this;
    const { ex: X2, ey: Y2, ez: Z2 } = apoint(other);
    const X1Z2 = M(X1 * Z2);
    const X2Z1 = M(X2 * Z1);
    const Y1Z2 = M(Y1 * Z2);
    const Y2Z1 = M(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  is0() {
    return this.equals(I);
  }
  /** Flip point over y coordinate. */
  negate() {
    return new _Point(M(-this.ex), this.ey, this.ez, M(-this.et));
  }
  /** Point doubling. Complete formula. Cost: `4M + 4S + 1*a + 6add + 1*2`. */
  double() {
    const { ex: X1, ey: Y1, ez: Z1 } = this;
    const a = _a;
    const A = M(X1 * X1);
    const B = M(Y1 * Y1);
    const C2 = M(2n * M(Z1 * Z1));
    const D = M(a * A);
    const x1y1 = X1 + Y1;
    const E = M(M(x1y1 * x1y1) - A - B);
    const G2 = D + B;
    const F = G2 - C2;
    const H = D - B;
    const X3 = M(E * F);
    const Y3 = M(G2 * H);
    const T3 = M(E * H);
    const Z3 = M(F * G2);
    return new _Point(X3, Y3, Z3, T3);
  }
  /** Point addition. Complete formula. Cost: `8M + 1*k + 8add + 1*2`. */
  add(other) {
    const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
    const { ex: X2, ey: Y2, ez: Z2, et: T2 } = apoint(other);
    const a = _a;
    const d = _d;
    const A = M(X1 * X2);
    const B = M(Y1 * Y2);
    const C2 = M(T1 * d * T2);
    const D = M(Z1 * Z2);
    const E = M((X1 + Y1) * (X2 + Y2) - A - B);
    const F = M(D - C2);
    const G2 = M(D + C2);
    const H = M(B - a * A);
    const X3 = M(E * F);
    const Y3 = M(G2 * H);
    const T3 = M(E * H);
    const Z3 = M(F * G2);
    return new _Point(X3, Y3, Z3, T3);
  }
  /**
   * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
   * Uses {@link wNAF} for base point.
   * Uses fake point to mitigate side-channel leakage.
   * @param n scalar by which point is multiplied
   * @param safe safe mode guards against timing attacks; unsafe mode is faster
   */
  multiply(n, safe = true) {
    if (!safe && (n === 0n || this.is0()))
      return I;
    arange(n, 1n, N);
    if (n === 1n)
      return this;
    if (this.equals(G))
      return wNAF(n).p;
    let p = I;
    let f = G;
    for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
      if (n & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  /** Convert point to 2d xy affine point. (X, Y, Z) ∋ (x=X/Z, y=Y/Z) */
  toAffine() {
    const { ex: x, ey: y, ez: z } = this;
    if (this.equals(I))
      return { x: 0n, y: 1n };
    const iz = invert(z, P);
    if (M(z * iz) !== 1n)
      err("invalid inverse");
    return { x: M(x * iz), y: M(y * iz) };
  }
  toBytes() {
    const { x, y } = this.assertValidity().toAffine();
    const b = numTo32bLE(y);
    b[31] |= x & 1n ? 128 : 0;
    return b;
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  // encode to hex string
  clearCofactor() {
    return this.multiply(big(h3), false);
  }
  isSmallOrder() {
    return this.clearCofactor().is0();
  }
  isTorsionFree() {
    let p = this.multiply(N / 2n, false).double();
    if (N % 2n)
      p = p.add(this);
    return p.is0();
  }
  static fromHex(hex, zip215) {
    return _Point.fromBytes(toU8(hex), zip215);
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  toRawBytes() {
    return this.toBytes();
  }
};
var G = new Point(Gx, Gy, 1n, M(Gx * Gy));
var I = new Point(0n, 1n, 1n, 0n);
Point.BASE = G;
Point.ZERO = I;
var numTo32bLE = /* @__PURE__ */ __name((num) => hexToBytes(padh(arange(num, 0n, B256), L2)).reverse(), "numTo32bLE");
var bytesToNumLE = /* @__PURE__ */ __name((b) => big("0x" + bytesToHex(u8fr(abytes(b)).reverse())), "bytesToNumLE");
var pow2 = /* @__PURE__ */ __name((x, power) => {
  let r = x;
  while (power-- > 0n) {
    r *= r;
    r %= P;
  }
  return r;
}, "pow2");
var pow_2_252_3 = /* @__PURE__ */ __name((x) => {
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, 2n) * b2 % P;
  const b5 = pow2(b4, 1n) * x % P;
  const b10 = pow2(b5, 5n) * b5 % P;
  const b20 = pow2(b10, 10n) * b10 % P;
  const b40 = pow2(b20, 20n) * b20 % P;
  const b80 = pow2(b40, 40n) * b40 % P;
  const b160 = pow2(b80, 80n) * b80 % P;
  const b240 = pow2(b160, 80n) * b80 % P;
  const b250 = pow2(b240, 10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, 2n) * x % P;
  return { pow_p_5_8, b2 };
}, "pow_2_252_3");
var RM1 = 0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n;
var uvRatio = /* @__PURE__ */ __name((u, v) => {
  const v3 = M(v * v * v);
  const v7 = M(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = M(u * v3 * pow);
  const vx2 = M(v * x * x);
  const root1 = x;
  const root2 = M(x * RM1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === M(-u);
  const noRoot = vx2 === M(-u * RM1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if ((M(x) & 1n) === 1n)
    x = M(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}, "uvRatio");
var modL_LE = /* @__PURE__ */ __name((hash) => modN(bytesToNumLE(hash)), "modL_LE");
var sha512a = /* @__PURE__ */ __name((...m) => etc.sha512Async(...m), "sha512a");
var hash2extK = /* @__PURE__ */ __name((hashed) => {
  const head = hashed.slice(0, L);
  head[0] &= 248;
  head[31] &= 127;
  head[31] |= 64;
  const prefix = hashed.slice(L, L2);
  const scalar = modL_LE(head);
  const point = G.multiply(scalar);
  const pointBytes = point.toBytes();
  return { head, prefix, scalar, point, pointBytes };
}, "hash2extK");
var getExtendedPublicKeyAsync = /* @__PURE__ */ __name((priv) => sha512a(toU8(priv, L)).then(hash2extK), "getExtendedPublicKeyAsync");
var getPublicKeyAsync = /* @__PURE__ */ __name((priv) => getExtendedPublicKeyAsync(priv).then((p) => p.pointBytes), "getPublicKeyAsync");
var hashFinishA = /* @__PURE__ */ __name((res) => sha512a(res.hashable).then(res.finish), "hashFinishA");
var _sign = /* @__PURE__ */ __name((e, rBytes, msg) => {
  const { pointBytes: P2, scalar: s } = e;
  const r = modL_LE(rBytes);
  const R = G.multiply(r).toBytes();
  const hashable = concatBytes(R, P2, msg);
  const finish = /* @__PURE__ */ __name((hashed) => {
    const S = modN(r + modL_LE(hashed) * s);
    return abytes(concatBytes(R, numTo32bLE(S)), L2);
  }, "finish");
  return { hashable, finish };
}, "_sign");
var signAsync = /* @__PURE__ */ __name(async (msg, privKey) => {
  const m = toU8(msg);
  const e = await getExtendedPublicKeyAsync(privKey);
  const rBytes = await sha512a(e.prefix, m);
  return hashFinishA(_sign(e, rBytes, m));
}, "signAsync");
var veriOpts = { zip215: true };
var _verify = /* @__PURE__ */ __name((sig, msg, pub, opts = veriOpts) => {
  sig = toU8(sig, L2);
  msg = toU8(msg);
  pub = toU8(pub, L);
  const { zip215 } = opts;
  let A;
  let R;
  let s;
  let SB;
  let hashable = Uint8Array.of();
  try {
    A = Point.fromHex(pub, zip215);
    R = Point.fromHex(sig.slice(0, L), zip215);
    s = bytesToNumLE(sig.slice(L, L2));
    SB = G.multiply(s, false);
    hashable = concatBytes(R.toBytes(), A.toBytes(), msg);
  } catch (error) {
  }
  const finish = /* @__PURE__ */ __name((hashed) => {
    if (SB == null)
      return false;
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = modL_LE(hashed);
    const RkA = R.add(A.multiply(k, false));
    return RkA.add(SB.negate()).clearCofactor().is0();
  }, "finish");
  return { hashable, finish };
}, "_verify");
var verifyAsync = /* @__PURE__ */ __name(async (s, m, p, opts = veriOpts) => hashFinishA(_verify(s, m, p, opts)), "verifyAsync");
var etc = {
  sha512Async: /* @__PURE__ */ __name(async (...messages) => {
    const s = subtle();
    const m = concatBytes(...messages);
    return u8n(await s.digest("SHA-512", m.buffer));
  }, "sha512Async"),
  sha512Sync: void 0,
  bytesToHex,
  hexToBytes,
  concatBytes,
  mod: M,
  invert,
  randomBytes
};
var W = 8;
var scalarBits = 256;
var pwindows = Math.ceil(scalarBits / W) + 1;
var pwindowSize = 2 ** (W - 1);
var precompute = /* @__PURE__ */ __name(() => {
  const points = [];
  let p = G;
  let b = p;
  for (let w = 0; w < pwindows; w++) {
    b = p;
    points.push(b);
    for (let i = 1; i < pwindowSize; i++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
}, "precompute");
var Gpows = void 0;
var ctneg = /* @__PURE__ */ __name((cnd, p) => {
  const n = p.negate();
  return cnd ? n : p;
}, "ctneg");
var wNAF = /* @__PURE__ */ __name((n) => {
  const comp = Gpows || (Gpows = precompute());
  let p = I;
  let f = G;
  const pow_2_w = 2 ** W;
  const maxNum = pow_2_w;
  const mask = big(pow_2_w - 1);
  const shiftBy = big(W);
  for (let w = 0; w < pwindows; w++) {
    let wbits = Number(n & mask);
    n >>= shiftBy;
    if (wbits > pwindowSize) {
      wbits -= maxNum;
      n += 1n;
    }
    const off = w * pwindowSize;
    const offF = off;
    const offP = off + Math.abs(wbits) - 1;
    const isEven = w % 2 !== 0;
    const isNeg = wbits < 0;
    if (wbits === 0) {
      f = f.add(ctneg(isEven, comp[offF]));
    } else {
      p = p.add(ctneg(isNeg, comp[offP]));
    }
  }
  return { p, f };
}, "wNAF");

// src/http.ts
var HttpServer = class extends import_core6.Adapter {
  static {
    __name(this, "HttpServer");
  }
  static inject = ["server"];
  async connect(bot) {
    if (bot.config.authType === "bearer") {
      await bot.getAccessToken();
    }
    await this.initialize(bot);
    bot.ctx.server.post(bot.config.path, async (ctx) => {
      const bot2 = this.bots.find((bot3) => bot3.config.id === ctx.get("X-Bot-Appid"));
      if (!bot2) return ctx.status = 403;
      ctx.status = 200;
      const payload = ctx.request.body;
      if (payload.op === 13 /* ADDRESS_VERIFICATION */) {
        const key = this.getPrivateKey(bot2.config.secret);
        const data = payload.d.event_ts + payload.d.plain_token;
        const sig = await signAsync(new TextEncoder().encode(data), key);
        return ctx.body = {
          plain_token: payload.d.plain_token,
          signature: import_core6.Binary.toHex(sig)
        };
      } else if (payload.op === 0 /* DISPATCH */) {
        const key = this.getPrivateKey(bot2.config.secret);
        const body = ctx.request.body[Symbol.for("unparsedBody")];
        if (!await this.verify(key, ctx.request.header, body)) {
          return ctx.status = 403;
        }
        if (bot2.status !== import_core6.Universal.Status.ONLINE) {
          await this.initialize(bot2);
        }
        bot2.dispatch(bot2.session({
          type: "internal",
          _type: "qq/" + payload.t.toLowerCase().replace(/_/g, "-"),
          _data: payload.d
        }));
        const session = await adaptSession(bot2, payload);
        if (session) bot2.dispatch(session);
      }
      ctx.body = {
        d: {},
        op: 12 /* HTTP_CALLBACK_ACK */
      };
    });
  }
  async initialize(bot) {
    try {
      await bot.initialize();
      bot.online();
    } catch (e) {
      if (bot.http.isError(e) && e.response) {
        bot.logger.warn(`GET /users/@me response: %o`, e.response.data);
      } else {
        bot.logger.warn(e);
      }
      bot.offline();
    }
  }
  getPrivateKey(secret) {
    const seedSize = 32;
    let seed = secret;
    if (seed.length < seedSize) {
      seed = seed + seed.slice(0, seedSize - seed.length);
    }
    return new TextEncoder().encode(seed);
  }
  async verify(privateKey, header, body) {
    const sig = import_core6.Binary.fromHex(header["x-signature-ed25519"]);
    const timestamp = header["x-signature-timestamp"];
    const msg = timestamp + body;
    const pubKey = await getPublicKeyAsync(privateKey);
    return verifyAsync(new Uint8Array(sig), new TextEncoder().encode(msg), pubKey);
  }
};
((HttpServer2) => {
  HttpServer2.Options = import_core6.Schema.object({
    protocol: import_core6.Schema.const("webhook").required(),
    path: import_core6.Schema.string().role("url").description("服务器监听的路径。").default("/qq")
  });
})(HttpServer || (HttpServer = {}));

// src/bot/index.ts
var QQBot = class extends import_core7.Bot {
  static {
    __name(this, "QQBot");
  }
  static MessageEncoder = QQMessageEncoder;
  static inject = {
    required: ["http"],
    optional: ["server"]
  };
  guildBot;
  internal;
  http;
  _token;
  _timer;
  constructor(ctx, config) {
    super(ctx, config, "qq");
    let endpoint = config.endpoint;
    if (config.sandbox) {
      endpoint = endpoint.replace(/^(https?:\/\/)/, "$1sandbox.");
    }
    this.http = this.ctx.http.extend({
      endpoint,
      headers: {
        "Authorization": this.config.authType === "bot" ? `Bot ${this.config.id}.${this.config.token}` : "",
        "X-Union-Appid": this.config.id
      }
    });
    this.ctx.plugin(QQGuildBot, {
      parent: this
    });
    this.internal = new GroupInternal(this, () => this.http);
    if (config.protocol === "websocket") {
      this.ctx.plugin(WsClient, this);
    } else {
      this.ctx.plugin(HttpServer, this);
    }
  }
  async initialize() {
    const user = await this.guildBot.internal.getMe();
    if (!this.user) this.user = decodeUser(user);
    else Object.assign(this.user, decodeUser(user));
  }
  async stop() {
    clearTimeout(this._timer);
    if (this.guildBot) {
      delete this.ctx.bots[this.guildBot.sid];
    }
    await super.stop();
  }
  async _ensureAccessToken() {
    try {
      const result = await this.ctx.http("https://bots.qq.com/app/getAppAccessToken", {
        method: "POST",
        data: {
          appId: this.config.id,
          clientSecret: this.config.secret
        }
      });
      if (!result.data.access_token) {
        this.logger.warn(`POST https://bots.qq.com/app/getAppAccessToken response: %o, trace id: %s`, result.data, result.headers.get("x-tps-trace-id"));
        throw new Error("failed to refresh access token");
      }
      this._token = result.data.access_token;
      this.http.config.headers.Authorization = `QQBot ${this._token}`;
      this._timer = setTimeout(() => {
        this._ensureAccessToken();
      }, (result.data.expires_in - 40) * 1e3);
    } catch (e) {
      if (!this.ctx.http.isError(e) || !e.response) throw e;
      this.logger.warn(`POST https://bots.qq.com/app/getAppAccessToken response: %o, trace id: %s`, e.response.data, e.response.headers.get("x-tps-trace-id"));
      throw e;
    }
  }
  async getAccessToken() {
    if (!this._token) {
      await this._ensureAccessToken();
    }
    return this._token;
  }
  async getLogin() {
    return this.toJSON();
  }
  async createDirectChannel(id) {
    return { id, type: import_core7.Universal.Channel.Type.DIRECT };
  }
  async deleteMessage(channelId, messageId) {
    try {
      await this.internal.deleteMessage(channelId, messageId);
    } catch (e) {
      await this.internal.deletePrivateMessage(channelId, messageId);
    }
  }
};
((QQBot2) => {
  QQBot2.Config = import_core7.Schema.intersect([
    import_core7.Schema.object({
      id: import_core7.Schema.string().description("机器人 id。").required(),
      secret: import_core7.Schema.string().description("机器人密钥。").role("secret"),
      token: import_core7.Schema.string().description("机器人令牌。").role("secret"),
      type: import_core7.Schema.union(["public", "private"]).description("机器人类型。").required(),
      sandbox: import_core7.Schema.boolean().description("是否开启沙箱模式。").default(false),
      endpoint: import_core7.Schema.string().role("link").description("要连接的服务器地址。").default("https://api.sgroup.qq.com/"),
      authType: import_core7.Schema.union(["bot", "bearer"]).description("采用的验证方式。").default("bearer"),
      intents: import_core7.Schema.bitset(Intents).description("需要订阅的机器人事件。"),
      retryWhen: import_core7.Schema.array(Number).description("发送消息遇到平台错误码时重试。").default([]),
      protocol: import_core7.Schema.union(["websocket", "webhook"]).description("选择要使用的协议。").default("websocket")
    }),
    import_core7.Schema.union([
      WsClient.Options,
      HttpServer.Options
    ]),
    import_core7.Schema.object({
      manualAcknowledge: import_core7.Schema.boolean().description("手动响应回调消息。").default(false),
      gatewayUrl: import_core7.Schema.string().role("link").description("覆写 WebSocket 地址。")
    }).description("高级设置")
  ]);
})(QQBot || (QQBot = {}));

// src/index.ts
var src_default = QQBot;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  QQ,
  QQBot,
  QQGuildMessageEncoder,
  QQMessageEncoder,
  WsClient,
  adaptSession,
  decodeChannel,
  decodeGroupMessage,
  decodeGuild,
  decodeGuildMember,
  decodeMessage,
  decodeUser,
  escapeMarkdown,
  setupReaction
});
/*! Bundled license information:

@noble/ed25519/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
